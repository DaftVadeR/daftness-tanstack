// This file was generated by ChatGPT as a test to see how it compares 
// to Grok and Gemini, which have been my primary AI tools at work.

// It's not perfect. But good enough for v1 until i finish mine, which i built myself. 

import React, { useMemo, useRef } from "react";
import { useGSAP } from "@gsap/react";

type MatrixEffectProps = {
    cellSize?: number; // px
    triggers?: number;
    trailLen?: number; // how many rows behind the trigger get “revealed”
    speedRows?: [number, number]; // rows/sec
    backgroundAlpha?: number; // base background opacity
    revealAlpha?: number; // max opacity for revealed cells
    revealTTL?: number; // seconds a revealed cell stays bright
    driftBackground?: boolean; // optional slow drift down
    scanlines?: boolean;
    className?: string;
};

type Trigger = {
    col: number;
    y: number; // rows float
    speed: number; // rows/sec
};

export default function MatrixEffect({
    cellSize = 14,
    triggers = 10,
    trailLen = 14,
    speedRows = [18, 40],
    backgroundAlpha = 0.08,
    revealAlpha = 0.45,
    revealTTL = 0.55,
    driftBackground = false,
    scanlines = true,
    className,
}: MatrixEffectProps) {
    const wrapRef = useRef<HTMLDivElement | null>(null);
    const canvasRef = useRef<HTMLCanvasElement | null>(null);

    const hiraganaSugoi = useMemo(() => ["す", "ご", "い"] as const, []);
    const runningRef = useRef(false);

    const stateRef = useRef<{
        dpr: number;
        w: number;
        h: number;
        cols: number;
        rows: number;

        bgBits: Uint8Array;
        bgCanvas: HTMLCanvasElement;

        revealIdx: Uint32Array;
        revealTtl: Float32Array;
        revealHead: number;
        revealCap: number;

        trig: Trigger[];

        drift: number;
        lastT: number;

        font: string;

        scanStrip?: HTMLCanvasElement;
        scanPhase: number;
    } | null>(null);

    useGSAP(() => {
        const wrap = wrapRef.current;
        const canvas = canvasRef.current;
        if (!wrap || !canvas) return;

        const ctx = canvas.getContext("2d", { alpha: true });
        if (!ctx) return;

        const rand = (min: number, max: number) => min + Math.random() * (max - min);
        const randInt = (min: number, max: number) =>
            (min + Math.floor(Math.random() * (max - min + 1))) | 0;

        const idx = (c: number, r: number, cols: number) => r * cols + c;

        const buildScanStrip = (w: number, dpr: number) => {
            const stripH = 4; // css px
            const c = document.createElement("canvas");
            c.width = Math.max(1, Math.floor(w * dpr));
            c.height = Math.max(1, Math.floor(stripH * dpr));
            const g = c.getContext("2d");
            if (!g) return c;
            g.setTransform(dpr, 0, 0, dpr, 0, 0);
            g.clearRect(0, 0, w, stripH);
            g.fillStyle = "rgba(0,0,0,0.45)";
            g.fillRect(0, 1, w, 1);
            return c;
        };

        const rebuild = (w: number, h: number) => {
            const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1)); // cap DPR for perf
            const cols = Math.max(1, Math.floor(w / cellSize));
            const rows = Math.max(1, Math.floor(h / cellSize));
            const count = cols * rows;

            canvas.width = Math.max(1, Math.floor(w * dpr));
            canvas.height = Math.max(1, Math.floor(h * dpr));
            canvas.style.width = `${w}px`;
            canvas.style.height = `${h}px`;

            const bgBits = new Uint8Array(count);
            for (let i = 0; i < count; i++) bgBits[i] = Math.random() < 0.5 ? 0 : 1;

            const bgCanvas = document.createElement("canvas");
            bgCanvas.width = canvas.width;
            bgCanvas.height = canvas.height;

            const bgCtx = bgCanvas.getContext("2d", { alpha: true });
            if (bgCtx) {
                bgCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
                bgCtx.clearRect(0, 0, w, h);

                bgCtx.font = `${cellSize}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace`;
                bgCtx.textBaseline = "top";
                bgCtx.fillStyle = "rgb(0 255 120)";
                bgCtx.globalAlpha = backgroundAlpha;

                for (let r = 0; r < rows; r++) {
                    const y = r * cellSize;
                    for (let c = 0; c < cols; c++) {
                        const i = idx(c, r, cols);
                        bgCtx.fillText(bgBits[i] ? "1" : "0", c * cellSize, y);
                    }
                }
                bgCtx.globalAlpha = 1;
            }

            const revealCap = Math.max(512, triggers * trailLen * 6);
            const revealIdx = new Uint32Array(revealCap);
            const revealTtl = new Float32Array(revealCap);

            const trig: Trigger[] = Array.from({ length: Math.max(1, triggers) }, () => ({
                col: randInt(0, cols - 1),
                y: rand(-rows, 0),
                speed: rand(speedRows[0], speedRows[1]),
            }));

            const font = `${cellSize}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace`;

            stateRef.current = {
                dpr,
                w,
                h,
                cols,
                rows,
                bgBits,
                bgCanvas,
                revealIdx,
                revealTtl,
                revealHead: 0,
                revealCap,
                trig,
                drift: 0,
                lastT: performance.now(),
                font,
                scanStrip: scanlines ? buildScanStrip(w, dpr) : undefined,
                scanPhase: 0,
            };
        };

        // resize throttle + debounce
        let ro: ResizeObserver | null = null;
        let resizeRaf = 0;
        let resizeTimer = 0;
        let pendingW = 0;
        let pendingH = 0;

        const scheduleRebuild = (w: number, h: number) => {
            pendingW = w | 0;
            pendingH = h | 0;

            if (!resizeRaf) {
                resizeRaf = requestAnimationFrame(() => {
                    resizeRaf = 0;
                    if (resizeTimer) window.clearTimeout(resizeTimer);
                    resizeTimer = window.setTimeout(() => {
                        resizeTimer = 0;
                        rebuild(pendingW, pendingH);
                    }, 180);
                });
            }
        };

        ro = new ResizeObserver((entries) => {
            const cr = entries[0]?.contentRect;
            if (!cr) return;
            scheduleRebuild(Math.max(1, (cr.width | 0)), Math.max(1, (cr.height | 0)));
        });
        ro.observe(wrap);

        const r = wrap.getBoundingClientRect();
        rebuild(Math.max(1, (r.width | 0)), Math.max(1, (r.height | 0)));

        const pushReveal = (cellIndex: number) => {
            const S = stateRef.current;
            if (!S) return;
            const j = S.revealHead;
            S.revealIdx[j] = cellIndex >>> 0;
            S.revealTtl[j] = revealTTL; // overwrite old
            S.revealHead = (j + 1) % S.revealCap;
        };

        let raf = 0;

        const frame = (now: number) => {
            if (!runningRef.current) return;

            const S = stateRef.current;
            if (!S) {
                raf = requestAnimationFrame(frame);
                return;
            }

            let dt = (now - S.lastT) / 1000;
            S.lastT = now;
            if (dt > 0.05) dt = 0.05;

            if (driftBackground) {
                S.drift += dt * 0.35;
                if (S.drift > S.rows) S.drift -= S.rows;
            }
            if (scanlines) S.scanPhase += dt * 1.5;

            // update triggers + emit reveals
            for (let t = 0; t < S.trig.length; t++) {
                const tr = S.trig[t];
                tr.y += tr.speed * dt;

                if (tr.y > S.rows + 6) {
                    tr.col = randInt(0, S.cols - 1);
                    tr.y = rand(-S.rows * 0.6, 0);
                    tr.speed = rand(speedRows[0], speedRows[1]);
                }

                const head = tr.y | 0;
                const start = Math.max(0, head - trailLen);
                const end = Math.min(S.rows - 1, head);

                for (let rr = start; rr <= end; rr++) {
                    pushReveal(idx(tr.col, rr, S.cols));
                }
            }

            // render
            ctx.setTransform(S.dpr, 0, 0, S.dpr, 0, 0);
            ctx.clearRect(0, 0, S.w, S.h);

            // background (pre-rendered)
            if (!driftBackground) {
                ctx.drawImage(S.bgCanvas, 0, 0, S.w, S.h);
            } else {
                const dy = ((S.drift % S.rows) * cellSize) | 0;
                const topH = S.h - dy;
                ctx.drawImage(
                    S.bgCanvas,
                    0,
                    dy * S.dpr,
                    S.w * S.dpr,
                    topH * S.dpr,
                    0,
                    0,
                    S.w,
                    topH
                );
                ctx.drawImage(
                    S.bgCanvas,
                    0,
                    0,
                    S.w * S.dpr,
                    dy * S.dpr,
                    0,
                    topH,
                    S.w,
                    dy
                );
            }

            // reveals
            ctx.font = S.font;
            ctx.textBaseline = "top";
            ctx.fillStyle = "rgb(0 255 120)";

            for (let j = 0; j < S.revealCap; j++) {
                const ttl = (S.revealTtl[j] -= dt);
                if (ttl <= 0) {
                    S.revealTtl[j] = 0;
                    continue;
                }
                const a = Math.min(revealAlpha, (ttl / revealTTL) * revealAlpha);
                if (a < 0.02) continue;

                const cell = S.revealIdx[j] | 0;
                const r0 = (cell / S.cols) | 0;
                const c0 = cell - r0 * S.cols;

                ctx.globalAlpha = a;
                ctx.fillText(S.bgBits[cell] ? "1" : "0", c0 * cellSize, r0 * cellSize);
            }
            ctx.globalAlpha = 1;

            // trigger glyphs (top->bottom: す ご い)
            ctx.fillStyle = "rgb(200 255 235)";
            const len = hiraganaSugoi.length;

            for (let t = 0; t < S.trig.length; t++) {
                const tr = S.trig[t];
                const head = tr.y;

                for (let k = 0; k < len; k++) {
                    const rr = (head - (len - 1 - k)) | 0;
                    if (rr < 0 || rr >= S.rows) continue;

                    ctx.globalAlpha = k === len - 1 ? 1 : 0.75;
                    ctx.fillText(hiraganaSugoi[k], tr.col * cellSize, rr * cellSize);
                }
            }
            ctx.globalAlpha = 1;

            // scanlines
            if (scanlines && S.scanStrip) {
                ctx.globalAlpha = 0.12;
                const stripH = S.scanStrip.height / S.dpr;
                const phase = ((Math.sin(S.scanPhase) * 0.5 + 0.5) * stripH) % stripH;
                for (let y = -stripH + phase; y < S.h; y += stripH) {
                    ctx.drawImage(S.scanStrip, 0, y, S.w, stripH);
                }
                ctx.globalAlpha = 1;
            }

            raf = requestAnimationFrame(frame);
        };

        runningRef.current = true;
        raf = requestAnimationFrame(frame);

        return () => {
            runningRef.current = false;
            cancelAnimationFrame(raf);

            if (resizeRaf) cancelAnimationFrame(resizeRaf);
            if (resizeTimer) window.clearTimeout(resizeTimer);

            ro?.disconnect();
            ro = null;

            stateRef.current = null;

            canvas.width = 1;
            canvas.height = 1;
        };
    }, []);

    return (
        <div
            ref={wrapRef}
            className={className}
            style={{
                position: "absolute",
                inset: 0,
                overflow: "hidden",
                pointerEvents: "none",
            }}
            aria-hidden="true"
        >
            <canvas
                ref={canvasRef}
                style={{
                    position: "absolute",
                    inset: 0,
                    display: "block",
                }}
            />
        </div>
    );
}

